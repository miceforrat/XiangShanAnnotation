# XS_IFU说明文档

本文档介绍的是截至2024年9月香山昆明湖架构开源版本中前端的IFU模块设计，包含PredDecoder和PredChecker等子模块。为 了鼓励软件测试相关人才参与香山项目的验证，本文档面向处理器硬件方向零基础读者，旨在帮助理解香山源代码，并提供IFU模块使用万众一芯开放验证平台通过Python进行验证的参考方法。

## IFU功能概述

IFU（Instruction Fetch Unit）主要负责从内存中取出指令，用于后续的译码过程。

现代处理器为了提高指令执行的效率，采用了**流水线**设计，即将指令的执行过程分为取指令、译码等多个阶段，从而可以让多个指令的执行重叠起来。然而，在遇到分支指令时，如果我们仍然按照正常的方式对分支指令接下来的指令执行流水线的各个阶段时，当分支指令确定将要跳转后，我们就需要丢弃已经完成取指、译码的指令，重新从跳转的目标地址取指令，这样会导致执行效率下降。因此，需要采取**分支预测**技术，在分支指令执行结果产生之前，准确预测下一条指令的地址，直接对预测的地址进行取指，减少前述丢弃的发生。

而香山则采取了进一步的**预测块**技术，给定一个 PC，香山会预测出以这个PC开始的一个分支预测块，包括了接下来若干条指令的情况，如是否存在分支指令、分支指令的位置、是否跳转以及跳转目标等信息。所以，基于这样的设计，IFU将会接受一个预测块作为输入，在预测块的指导下完成取指。

但是，IFU并不直接存储指令，而是由FTQ在向IFU发送请求的同时，向ICache（指令缓存）也发送请求。ICache根据请求内容决定返回1个或2个缓存行，IFU在获取缓存行后核验并切分得到指令码、送入预译码子模块、预译码子模块负责从切分得到的指令码提取预译码信息——包括该指令是否是有效指令的开始、是否是RVC指令、是否是CFI指令、CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移等——判断最后2字节是否是有效指令的后半部分，并通过4字节组合得到32位指令码（组合的方式详见后文），在此基础上，进一步对所有的指令进行16位扩展。

分支预测技术不可避免地会遇到预测错误，然而，并不是所有预测错误都需要到执行产生结果后才会被发现，所以，我们需要提前在IFU中检查一些预测错误，这样就可以避免错误到几个流水级之后才被发现，于是我们在IFU中内置了PredChecker子模块。以下是PredChecker需要参与检查的错误：

jal预测错误：预测块的范围内存在jal指令，但是预测器没有对这条指令预测跳转

ret预测错误：预测块的范围内存在ret指令，但是预测器没有对这条指令预测跳转

无效指令预测错误：预测器对一条无效的指令（不在预测块范围内的，或者是32位指令的一部分）进行了预测

非CFI指令预测错误：预测器对一条有效但是不是CFI的指令进行了预测

转移目标地址错误：预测器给出的转移目标地址不正确。

如果检查出了jal和ret的预测错误，还需要修正预测块的指令范围。

PredChecker检查出结果后，如果存在错误，需要完成前端重定向，冲刷错误结果。如果检查正常，则将指令码和前端信息送到IBuffer。无论是否检测到预测错误，都需要将指令信息和误预测信息写回FTQ，FTQ将根据写回信息决定是否冲刷流水线。

对于不能在IFU检查出的预测错误，IFU将会接收BPU的冲刷请求，如果需要冲刷的指令在取指的指针之前，则需要对流水线进行冲刷。

IFU还需要考虑一种特殊情况，那就是在处理器上电复位的情况下，如果系统的内存初始化尚未完成，那么此时需要IFU向MMIO总线发送64位的请求从flash地址空间取指令执行，并且此时此时需要禁止对总线的预测执行，也就是等到IFU得到确切的下一条指令的地址才能继续向总线发送请求。同样地，可能存在一次请求无法得到完整指令码的情况，此时需要进行请求重发。具体的状态转移详见后文。



## XS_IFU功能说明

### 常量列表

本部分的意义在于，通过提供本小节所提及的常数，可以将IFU.scala以及必要相关文件 （如PreDecoder.scala 等）拿出来单独编译，可以删除前端的其它模块，独立编译IFU，以 适应香山中IFU模块日后的源码版本更新。目前尚不全，待补齐。

#### 参数说明

```scala
class NewIFU(implicit p: Parameters) extends XSModule
  with HasICacheParameters
  with HasXSParameter
  with HasIFUConst
  with HasPdConst
  with HasCircularQueuePtrHelper
  with HasPerfEvents
  with HasTlbConst
```

| 参数          | 解释                                |
| ------------- | ----------------------------------- |
| p: Parameters | 全局参数，也就是XiangShanParameters |



#### PredictWidth

这个常量表示的是预测块的宽度，相关的定义可以在parameters\.scala中找到：

```scala
trait HasXSParameter {
    ...
	def FetchWidth = coreParams.FetchWidth
	def PredictWidth = FetchWidth * (if (HasCExtension) 2 else 1)
```

而coreParams.FetchWidth的定义则在：

```scala
case class XSCoreParameters
(
	...
	FetchWidth: Int = 8,
```

所以，在RISCV的C扩展存在的情况下，PredictWidth的大小为16，否则为8

】

### XS_IFU流水级划分

香山的IFU一共分为5个阶段。

F0阶段：接收FTQ请求，同时告诉FTQ自己已经ready了

F1阶段：从FTQ请求中先计算出每个指令的pc，half\_pc、cut\_ptr（这是后续将icache返回的指令码进行切分的依据）

F2阶段：从icache获取响应数据（缓存行）并校验，提取出异常信息（包括页错误、访问错误、mmio信息）；生成预测到的指令范围（但这并不是一个数字，而是一个用多位表示的bool数组，该位为1表示这一指令在预测块范围内）；从缓存行中，利用上一阶段求出的cut\_ptr切分出17×2的初步指令码，最后进行预译码和指令扩展。

F3阶段：这一阶段主要是对译码阶段的结果进行与检查，以及MMIO状态下的处理逻辑。

WB（写回）阶段：将预检查的结果写回FTQ，并向IBuffer写指令码和前端信息。


### 接收FTQ取指令请求（F0流水级）

​	在F0流水级，IFU接收来自FTQ以预测块为单位的取指令请求。请求内容包括预测块起始地址、起始地址所在cache line的下一个cache line开始地址、下一个预测块的起始地址、该预测块在FTQ里的队列指针、该预测块有无taken的CFI指令（控制流指令）和该taken的CFI指令在预测块里的位置以及请求控制信号（请求是否有效和IFU是否ready）。每个预测块最多包含32字节指令码，最多为16条指令。IFU需要置位ready驱动FTQ向ICache发送请求。



### 指令切分产生初始指令码（F1、F2流水级）

F0流水级时，FTQ同时会向ICache发送取缓存行的指令。这是ICache在其S2流水级需要返回的，所以IFU在F2流水级才会得到ICache返回的缓存行。在此之前，IFU会在F1流水线先进行PC的计算，以及计算切分缓存行的指针。

进入F2流水级，IFU首先需要校验ICache返回的指令码（因为IFU的流水级会被冲刷，但是ICache的流水级不会）——这通过比对指令开始地址、下一缓存行的开始地址等完成。校验通过后，IFU将会针对每个指令，取出对应的异常信息、物理地址、客户物理地址等。同时，根据FTQ的taken信息，IFU将会计算该预测块在无跳转和跳转发生情况下的有效指令范围。无跳转情况下的指令有效范围ftr_range即当前预测块从起始地址到下一个预测块的起始地址的差值。有跳转情况下的指令有效范围jump_range即当前预测块的起始地址到预测块中第一个跳转指令地址的差值。

最后，IFU需要从缓存行和上一流水级计算的指针，完成对17x2字节初始指令码的拼接。这里的拼接代码可能存在一些迷惑性
```scala
  val f2_cache_response_data = fromICache.map(_.bits.data)
  val f2_data_2_cacheline = Cat(f2_cache_response_data(0), f2_cache_response_data(0))
```
在调用cut之前，我们先是从ICache获取了缓存行（ICache返回的缓存行种类已经在ICache中进行了分类讨论，IFU中直接使用即可），然后将第0个缓存数据进行了拼接，这一操作的原因来自于ICache中对数据的细粒度拆分（参阅ICache的相关文档和代码），所以只需要把返回的cacheline复制一份拼接在一起，从中间截取就可以拿到数据。



### 预译码（F2流水级，主要由PreDecode模块完成）
在F2流水级，我们需要将上一步完成切分的指令码交给PreDecode子模块,他的作用主要有二：  

其一是生成预译码信息，包括该指令是否是有效指令的开始、是否是RVC指令、是否是CFI指令、CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移等。输出的预译码信息中brType域的编码如下:

| CFI指令类型 | brType类型编码 |
| --- | --- |
| 非CFI | 00 | 
| branch指令 | 01 |
| jal指令 | 10 |
| jalr指令 | 11 | 

其二是将初始指令码两两组合之后，得到16x4字节的指令码（从起始地址开始，2字节做地址递增，地址开始的4字节作为一条32位初始指令码）。

其他功能和详细内容参见PreDecode子模块的描述。

### 指令扩展（F3流水级）

这一部分将从PreDecode返回的16条指令码分别送交指令扩展器进行32位指令扩展（RVI保持不变， RVC指令根据手册的规定进行扩充）

### 预测错误预检查（F3流水级，主要由PreChecker子模块完成）

这一功能是为了将一些不依赖于执行结果的预测错误在早期就发现出来。这一阶段检查五类错误：

**jal类型错误**：预测块的范围内有jal指令，但是预测器没有对这条指令预测跳转；

**ret类型错误**：预测块的范围内有ret指令，但是预测器没有对这条指令预测跳转；

**无效指令预测错误**：预测器对一条无效的指令（不在预测块范围/是一条32位指令中间）进行了预测；

**非CFI指令预测错误**：预测器对一条有效但是不是CFI的指令进行了预测；

**转移目标地址错误**：预测器给出的转移目标地址不正确。

在预检查的最后将会修正之前预测的各个指令的跳转情况。同时，如果存在jal或者ret类型预测错误，还将修正fixedRange——这是指令有效范围向量，可以看作一个bool数组，其中某一位为1也就是对应的指令在这一范围内。

### 前端重定向（WB阶段）
如果在预测错误预检查的部分发现了上述的五类错误，那么需要在写回阶段产生一个前端重定向将F3以外的流水级进行冲刷。 

### 跨预测块32位指令处理
此外，还有一种情况需要完成流水线冲刷，也就是
```scala
    def hasLastHalf(idx: UInt) = {
    !f3_pd(idx).isRVC && checkerOutStage1.fixedRange(idx) && f3_instr_valid(idx) && !checkerOutStage1.fixedTaken(idx) && ! f3_req_is_mmio
  }
  
  val f3_false_lastHalf      = hasLastHalf(f3_last_validIdx)

  val wb_false_lastHalf = RegEnable(f3_false_lastHalf, wb_enable) && wb_lastIdx =/= (PredictWidth - 1).U
  val wb_false_target   = RegEnable(f3_false_snpc, wb_enable)

  val wb_half_flush = wb_false_lastHalf

checkFlushWb.bits.misOffset.valid   := ParallelOR(wb_check_result_stage2.fixedMissPred) || wb_half_flush
```
所述的内容

因为预测块的长度有限制，因此存在一条RVI指令前后两字节分别在两个预测块的情况。IFU首先在第一个预测块里检查最后2字节是不是一条RVI指令的开始，如果是并且该预测块没有跳转，那么就设置一个标识寄存器f3_lastHalf_valid，告诉接下来的预测块含有后半条指令。在F2预译码时，会产生两种不同的指令有效向量：

预测块起始地址开始即为一条指令的开始，以这种方式根据后续指令是RVC还是RVI产生指令有效向量

预测块起始地址是一条RVI指令的中间，以起始地址 + 2位一条指令的开始产生有效向量

在F3，根据是否有跨预测块RVI标识来决定选用哪种作为最终的指令有效向量，如果f3_lastHalf_valid为高则选择后一种（即这个预测块第一个2字节不是指令的开始）。IFU所做的处理只是把这条指令算在第一个预测块里，而把第二个预测块的起始地址位置的2字节通过改变指令有效向量来无效掉。

### 将指令码和前端信息送入IBuffer（F3流水级）

F3流水级最终得到经过扩展的32位指令码，以及16条指令中每条指令的例外信息、预译码信息、FTQ队列中的指针位置、其他后端需要的信息（比如经过折叠的PC）等。IFU除了常规的valid-ready控制信号外，还会给IBuffer两个特殊的信号：一个是16位的io_toIbuffer_bits_valid（因为我们最后组合出来的指令也是16条，所以这里每一位刚好也对应一个指令的状态，为1说明是一条指令的开始，为0则是说明是一条指令的中间），标识预测块里有效的指令。另一个是16位的io_toIbuffer_bits_enqEnable，这个在io_toIbuffer_bits_valid的基础上与上了被修正过的预测块的指令范围fixedRange。enqEnable为1表示这个2字节指令码是一条指令的开始且在预测块表示的指令范围内。

除此之外，异常信息也需要写给IBuffer。

### 分支预测overriding冲刷流水线（F3流水级）
当FTQ内未缓存足够预测块时，IFU可能直接使用简单分支预测器提供的预测地址进行取指，这种情况下，当精确预测器发现简单预测器错误时，需要通知IFU取消正在进行的取指请求。具体而言，当BPU的S2流水级发现错误时，需要冲刷IFU的F0流水级；当BPU的S3流水级发现错误时，需要冲刷IFU的F0/F1流水级（BPU的简单预测器在S1给出结果，最晚在S3进行overriding，因此IFU的F2/F3流水级一定是最好的预测，不需要冲刷；类似地，不存在BPU S2到IFU F1的冲刷）。

IFU在收到BPU发送的冲刷请求时，会将F0Ff1流水级上取指请求的指针与BPU发送的冲刷请求的指针进行比较，若冲刷的指针在取指的指针之前，说明当前取指请求在错误的执行路径上，需要进行流水线冲刷；反之，IFU可以忽略BPU发送的这一冲刷请求。


### 指令信息和误预测信息写回FTQ（WB阶段）
在F3的下一级WB级，IFU将指令PC、预译码信息、错误预测指令的位置、正确的跳转地址以及预测块的正确指令范围等信息写回FTQ，同时传递该预测块的FTQ指针用以区分不同请求。

同时，正如前面提到的，IFU检测到预测错误时会进行前端冲刷，同样地，FTQ也需要据此进行冲刷，因此，这也是IFU写回错误信息的意义——可以辅助FTQ判断是否冲刷流水线。


