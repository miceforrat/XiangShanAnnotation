# XS_IFU说明文档

本文档介绍的是截至2024年9月香山昆明湖架构开源版本中前端的IFU模块设计，包含PredDecoder和PredChecker等子模块。为 了鼓励软件测试相关人才参与香山项目的验证，本文档面向处理器硬件方向零基础读者，旨在帮助理解香山源代码，并提供IFU模块使用万众一芯开放验证平台通过Python进行验证的参考方法。

## IFU功能概述

IFU（Instruction Fetch Unit）主要负责从内存中取出指令，用于后续的译码过程。

现代处理器为了提高指令执行的效率，采用了**流水线**设计，即将指令的执行过程分为取指令、译码等多个阶段，从而可以让多个指令的执行重叠起来。然而，在遇到分支指令时，如果我们仍然按照正常的方式对分支指令接下来的指令执行流水线的各个阶段时，当分支指令确定将要跳转后，我们就需要丢弃已经完成取指、译码的指令，重新从跳转的目标地址取指令，这样会导致执行效率下降。因此，需要采取**分支预测**技术，在分支指令执行结果产生之前，准确预测下一条指令的地址，直接对预测的地址进行取指，减少前述丢弃的发生。

而香山则采取了进一步的**预测块**技术，给定一个 PC，香山会预测出以这个PC开始的一个分支预测块，包括了接下来若干条指令的情况，如是否存在分支指令、分支指令的位置、是否跳转以及跳转目标等信息。所以，基于这样的设计，IFU将会接受一个预测块作为输入，在预测块的指导下完成取指。

但是，IFU并不直接存储指令，而是由FTQ在向IFU发送请求的同时，向ICache（指令缓存）也发送请求。ICache根据请求内容决定返回1个或2个缓存行，IFU在获取缓存行后核验并切分得到指令码、送入预译码子模块、预译码子模块负责从切分得到的指令码提取预译码信息——包括该指令是否是有效指令的开始、是否是RVC指令、是否是CFI指令、CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移等——判断最后2字节是否是有效指令的后半部分，并通过4字节组合得到32位指令码（组合的方式详见后文），在此基础上，进一步对所有的指令进行16位扩展。

分支预测技术不可避免地会遇到预测错误，然而，并不是所有预测错误都需要到执行产生结果后才会被发现，所以，我们需要提前在IFU中检查一些预测错误，这样就可以避免错误到几个流水级之后才被发现，于是我们在IFU中内置了PredChecker子模块。以下是PredChecker需要参与检查的错误：

jal预测错误：预测块的范围内存在jal指令，但是预测器没有对这条指令预测跳转

ret预测错误：预测块的范围内存在ret指令，但是预测器没有对这条指令预测跳转

无效指令预测错误：预测器对一条无效的指令（不在预测块范围内的，或者是32位指令的一部分）进行了预测

非CFI指令预测错误：预测器对一条有效但是不是CFI的指令进行了预测

转移目标地址错误：预测器给出的转移目标地址不正确。

如果检查出了jal和ret的预测错误，还需要修正预测块的指令范围。

PredChecker检查出结果后，如果存在错误，需要完成前端重定向，冲刷错误结果。如果检查正常，则将指令码和前端信息送到IBuffer。无论是否检测到预测错误，都需要将指令信息和误预测信息写回FTQ，FTQ将根据写回信息决定是否冲刷流水线。

对于不能在IFU检查出的预测错误，IFU将会接收BPU的冲刷请求，如果需要冲刷的指令在取指的指针之前，则需要对流水线进行冲刷。

IFU还需要考虑一种特殊情况，那就是在处理器上电复位的情况下，如果系统的内存初始化尚未完成，那么此时需要IFU向MMIO总线发送64位的请求从flash地址空间取指令执行，并且此时此时需要禁止对总线的预测执行，也就是等到IFU得到确切的下一条指令的地址才能继续向总线发送请求。同样地，可能存在一次请求无法得到完整指令码的情况，此时需要进行请求重发。具体的状态转移详见后文。



## XS_IFU功能说明

### 常量列表

本部分的意义在于，通过提供本小节所提及的常数，可以将IFU.scala以及必要相关文件 （如PreDecoder.scala 等）拿出来单独编译，可以删除前端的其它模块，独立编译IFU，以 适应香山中IFU模块日后的源码版本更新。目前尚不全，待补齐。

#### 参数说明

```scala
class NewIFU(implicit p: Parameters) extends XSModule
  with HasICacheParameters
  with HasXSParameter
  with HasIFUConst
  with HasPdConst
  with HasCircularQueuePtrHelper
  with HasPerfEvents
  with HasTlbConst
```

| 参数          | 解释                                |
| ------------- | ----------------------------------- |
| p: Parameters | 全局参数，也就是XiangShanParameters |



#### PredictWidth

这个常量表示的是预测块的宽度，相关的定义可以在parameters\.scala中找到：

```scala
trait HasXSParameter {
    ...
	def FetchWidth = coreParams.FetchWidth
	def PredictWidth = FetchWidth * (if (HasCExtension) 2 else 1)
```

而coreParams.FetchWidth的定义则在：

```scala
case class XSCoreParameters
(
	...
	FetchWidth: Int = 8,
```

所以，在RISCV的C扩展存在的情况下，PredictWidth的大小为16，否则为8

】

### XS_IFU流水级划分

香山的IFU一共分为5个阶段。

F0阶段：接收FTQ请求，同时告诉FTQ自己已经ready了

F1阶段：从FTQ请求中先计算出每个指令的pc，half\_pc、cut\_ptr（这是后续将icache返回的指令码进行切分的依据）

F2阶段：从icache获取响应数据（缓存行）并校验，提取出异常信息（包括页错误、访问错误、mmio信息）；生成预测到的指令范围（但这并不是一个数字，而是一个用多位表示的bool数组，该位为1表示这一指令在预测块范围内）；从缓存行中，利用上一阶段求出的cut\_ptr切分出17×2的初步指令码，最后进行预译码和指令扩展。

F3阶段：这一阶段主要是对译码阶段的结果进行与检查，以及MMIO状态下的处理逻辑。

WB（写回）阶段：将预检查的结果写回FTQ，并向IBuffer写指令码和前端信息。



### 接收FTQ取指令请求（F0流水级）

​	在F0流水级，IFU接收来自FTQ以预测块为单位的取指令请求。请求内容包括预测块起始地址、起始地址所在cache line的下一个cache line开始地址、下一个预测块的起始地址、该预测块在FTQ里的队列指针、该预测块有无taken的CFI指令（控制流指令）和该taken的CFI指令在预测块里的位置以及请求控制信号（请求是否有效和IFU是否ready）。每个预测块最多包含32字节指令码，最多为16条指令。IFU需要置位ready驱动FTQ向ICache发送请求。

​	

### 指令切分产生初始指令码（F1、F2流水级）

F0流水级时，FTQ同时会向ICache发送取缓存行的指令。这是ICache在其S2流水级需要返回的，所以IFU在F2流水级才会得到ICache返回的缓存行。在此之前，IFU会在F1流水线先进行PC的计算，以及计算切分缓存行的指针。

进入F2流水级，IFU首先需要校验ICache返回的指令码（因为IFU的流水级会被冲刷，但是ICache的流水级不会）——这通过比对指令开始地址、下一缓存行的开始地址等完成。校验通过后，IFU将会针对每个指令，取出对应的异常信息、物理地址、客户物理地址等。同时，根据FTQ的taken信息，也可计算该预测块在无跳转和跳转发生情况下的有效指令范围。

最后，IFU需要从缓存行和上一流水级计算的指针，计算出



